; результат компиляции надо вставить начиная с адреса $8FF00
; d0 = порядковый номер текущей строки
; a0 на входе - адрес начала блока-индекса (вначале служебные байты, байты 5-6 содержат строку, начиная с которой идет следующий блок)
; сигнальные номера строк записывать начиная с 8FFF0, таким образом, доступно 9 блоков
; Для начала нужно тот самый 0FF0 (или новое значение) из 90004 поместить по адресу 8FFF0, а остальные байты до 90000 оставить FF
; (нужно для того, чтобы проверка (a0) > d0 дала true и инкремент блока проскипался,
; чтобы оно заработало с модифицированным изначальным кодом
	move.l a0,-(sp)
	sub #$10,a0 ; индекс номеров строк, соответствующих новым блокам, будет располагаться на 16 байт выше основного блока
	; сейчас a0 = 8FFF0
	cmp.w (a0)+,d0 ; проверка второго блока, указатель одновременно смещается на 2 байта. 
		       ; Если (a0) > d0, т.е. еще не достигли сигнальной строки, то флаг поднимется
	bcs.s cleanup ; если флаг поднялся, то выходим из функции
	addq.w #1,d1 ; иначе инкрементим
	; сейчас a0 = 8FFF2
	cmp.w (a0)+,d0 ; #3
	bcs.s makeswap
	addq.w #1,d1
	; a0 = 8FFF4
	cmp.w (a0)+,d0 ; #4
	bcs.s makeswap
	addq.w #1,d1
	; a0 = 8FFF6
	cmp.w (a0)+,d0 ; #5
	bcs.s makeswap
	addq.w #1,d1
	; a0 = 8FFF8
	cmp.w (a0)+,d0 ; #6
	bcs.s makeswap
	addq.w #1,d1
	; a0 = 8FFFA
	cmp.w (a0)+,d0 ; #7
	bcs.s makeswap
	addq.w #1,d1
	; a0 = 8FFFC
	cmp.w (a0)+,d0 ; #8
	bcs.s makeswap
	addq.w #1,d1
	; a0 = 8FFFE
	cmp.w (a0)+,d0 ; #9
	bcs.s makeswap
	addq.w #1,d1
makeswap:
	swap d1
cleanup:
	move.l (sp)+,a0
	rts
